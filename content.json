{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"Hello World","date":"2018-08-19T06:28:54.602Z","updated":"2018-08-18T01:39:09.148Z","comments":true,"path":"hello-world.html","permalink":"http://yoursite.com/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}],"posts":[{"title":"Hexo+Github搭建专属博客","slug":"Hexo-Github搭建专属博客","date":"2018-08-18T08:15:04.000Z","updated":"2018-08-18T08:28:51.460Z","comments":true,"path":"2018/08/18/Hexo-Github搭建专属博客/","link":"","permalink":"http://yoursite.com/2018/08/18/Hexo-Github搭建专属博客/","excerpt":"","text":"前言：电脑系统为window 10专业版，64位 相关步骤： 1、安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下 2、安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择 注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图 3、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README 在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。 4、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面 输入npm install hexo -g，开始安装Hexo 输入hexo -v，检查hexo是否安装成功 输入hexo init，初始化该文件夹（有点漫长的等待。。。） 看到后面的“Start blogging with Hexo！”，激动有木有！！！！！ 输入npm install，安装所需要的组件 输入hexo g，首次体验Hexo 输入hexo s，开启服务器，访问该网址，正式体验Hexo 问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号 那么出现如下图就成功了 5、将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话） 上图是在其文件夹里面鼠标右键，点击Git Base Here。这里“feng”可以替换成自己的用户名，邮箱可以替换成自己的邮箱 输入cd ~/.ssh，检查是否由.ssh的文件夹 输入ls，列出该文件下的内容。下图说明存在 输入ssh-keygen -t rsa -C “929762930@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\\Users\\Administrator.ssh）。 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent 登录Github，点击头像下的settings，添加ssh 新建一个new ssh key，将id_rsa.pub文件里的内容复制上去 输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了 问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决 首先，清除所有的key-pair ssh-add -D rm -r ~/.ssh 删除你在github中的public-key 重新生成ssh密钥对 ssh-keygen -t rsa -C “xxx@xxx.com“ 接下来正常操作 在github上添加公钥public-key: 1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板 2、在github上添加公钥时，直接复制即可 3、保存 测试： 在终端 ssh -T git@github.com 6、配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾） repo值是你在github项目里的ssh（右下角） 7、新建一篇博客，在cmd执行命令：hexo new post “博客名” 这时候在文件夹_posts目录下将会看到已经创建的文件 在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save 使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了 部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章 好了，到此为止，最基本的也是最全面的hexo+github搭建博客完结。","categories":[],"tags":[]},{"title":"Python3中的bytes和str类型","slug":"Python3中的bytes和str类型","date":"2018-08-18T08:06:47.000Z","updated":"2018-08-18T08:09:25.933Z","comments":true,"path":"2018/08/18/Python3中的bytes和str类型/","link":"","permalink":"http://yoursite.com/2018/08/18/Python3中的bytes和str类型/","excerpt":"","text":"编码历史： 最早的字符编码规范是ASCII码，一种8位即1个字节的编码规范 以ASCII编码为例，它规定1个字节8个比特位代表1个字符的编码，也就是“00000000”这么宽，一个一个字节的解读。例如：01000001表示大写字母A，有时我们会“偷懒”的用65这个十进制来表示A在ASCII中的编码。8个比特位，可以没有重复的最多表示2的8次方(255)个字符。 后来，计算机得到普及，中文、日文、韩文等等国家的文字需要在计算机内表示，ASCII的255位远远不够，于是标准组织制定出了叫做UNICODE的万国码，它规定任何一个字符（不管哪国的）至少以2个字节表示，可以更多。其中，英文字母就是用2个字节，而汉字是3个字节。这个编码虽然很好，满足了所有人的要求，但是它不兼容ASCII，同时还占用较多的空间和内存。因为，在计算机世界更多的字符是英文字母，明明可以1个字节就能够表示，非要用2个。 于是UTF-8编码应运而生，它规定英文字母系列用1个字节表示，汉字用3个字节表示等等。因此，它兼容ASCII，可以解码早期的文档。UTF-8很快就得到了广泛的应用。 在编码的发展历程中，我国还创造了自己的编码方式，例如GBK，GB2312，BIG5。他们只局限于在国内使用，不被国外认可。在GBK编码中，中文汉字占2个字节。 Python有个内置函数bytes()可以将字符串str类型转换成bytes类型，b实际上是一串01的组合，但为了在ide环境中让我们相对直观的观察，它被表现成了b’\\xe4\\xb8\\xad\\xe6\\x96\\x87’这种形式，开头的b表示这是一个bytes类型。\\xe4是十六进制的表示方式，它占用1个字节的长度，因此”中文“被编码成utf-8后，我们可以数得出一共用了6个字节，每个汉字占用3个，这印证了上面的论述。在使用内置函数bytes()的时候，必须明确encoding的参数，不可省略。 我们都知道，字符串类str里有一个encode()方法，它是从字符串向比特流的编码过程。而bytes类型恰好有个decode()方法，它是从比特流向字符串解码的过程。除此之外，我们查看Python源码会发现bytes和str拥有几乎一模一样的方法列表，最大的区别就是encode和decode。 从实质上来说，字符串在磁盘上的保存形式也是01的组合，也需要编码解码。 1、在将字符串存入磁盘和从磁盘读取字符串的过程中，Python自动地帮你完成了编码和解码的工作，你不需要关心它的过程。 2、使用bytes类型，实质上是告诉Python，不需要它帮你自动地完成编码和解码的工作，而是用户自己手动进行，并指定编码格式。 3、Python已经严格区分了bytes和str两种数据类型，你不能在需要bytes类型参数的时候使用str参数，反之亦然。这点在读写磁盘文件时容易碰到。 在bytes和str的互相转换过程中，实际就是编码解码的过程，必须显式地指定编码格式。 我们再把字符串s1，转换成gbk编码的bytes类型： >&gt;&gt; s1’中文’&gt;&gt;&gt; type(s1)&gt;&gt;&gt; b = bytes(s1, encoding=’gbk’)&gt;&gt;&gt; bb’\\xd6\\xd0\\xce\\xc4’ 测试： if name == ‘main‘: ​ temp = b’steve’ ​ print(type(temp)) ​ ret = temp.decode(encoding=’utf-8’) ​ print(ret,type(ret)) ​ mbyte = ‘fuck’.encode(encoding=’utf-8’) ​ print(mbyte,type(mbyte)) ​ pass 结果：","categories":[],"tags":[]},{"title":"Json模块dumps、loads、dump、load函数","slug":"Json模块dumps、loads、dump、load函数","date":"2018-08-18T05:26:25.000Z","updated":"2018-08-18T05:28:24.798Z","comments":true,"path":"2018/08/18/Json模块dumps、loads、dump、load函数/","link":"","permalink":"http://yoursite.com/2018/08/18/Json模块dumps、loads、dump、load函数/","excerpt":"","text":"1、json.dumps() json.dumps()用于将dict类型的数据转成str，因为如果直接将dict类型的数据写入json文件中会发生报错，因此在将数据写入时需要用到该函数。 import json name_emb = {‘a’:’1111’,’b’:’2222’,’c’:’3333’,’d’:’4444’} jsObj = json.dumps(name_emb) print(name_emb) print(jsObj) print(type(name_emb)) print(type(jsObj)) 若在数据写入json文件时，未先进行转换，报错如下 import json name_emb = {‘a’:’1111’,’b’:’2222’,’c’:’3333’,’d’:’4444’} ​ emb_filename = (‘D:\\Pycharm2018\\pythonprogram\\emb_json.json’) # jsObj = json.dumps(name_emb) with open(emb_filename, “w”) as f: ​ f.write(name_emb) ​ f.close() 2、json.loads()json.loads()用于将str类型的数据转成dict。 import json name_emb = {‘a’:’1111’,’b’:’2222’,’c’:’3333’,’d’:’4444’} jsDumps = json.dumps(name_emb) jsLoads = json.loads(jsDumps) print(name_emb) print(jsDumps) print(jsLoads) print(type(name_emb)) print(type(jsDumps)) print(type(jsLoads)) 3、json.dump()json.dump()用于将dict类型的数据转成str，并写入到json文件中。 下面两种方法都可以将数据写入json文件： import json name_emb = {‘a’:’1111’,’b’:’2222’,’c’:’3333’,’d’:’4444’} ​ emb_filename = (‘D:\\Pycharm2018\\pythonprogram\\emb_json.json’) # solution 1 方法1： jsObj = json.dumps(name_emb) with open(emb_filename, “w”) as f: ​ f.write(jsObj) ​ f.close() ​ # solution 2 方法2： json.dump(name_emb, open(emb_filename, “w”)) 4、json.load()json.load()用于从json文件中读取数据。 import json emb_filename = (‘D:\\Pycharm2018\\pythonprogram\\emb_json.json’) jsObj = json.load(open(emb_filename)) print(jsObj) print(type(jsObj)) #遍历字典（键值对） for key in jsObj.keys(): ​ print(‘key: %s value: %s’ % (key,jsObj.get(key)))","categories":[],"tags":[]}]}